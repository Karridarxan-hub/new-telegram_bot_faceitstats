"""Admin queue management commands and utilities."""

import logging
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta

from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.filters import Command
from aiogram.enums import ParseMode

from queues.task_manager import get_task_manager, TaskPriority, TaskStatus
from utils.admin import AdminManager
from bot.queue_handlers import user_active_tasks, get_user_active_tasks, cleanup_completed_tasks
from bot.callbacks import get_registered_callbacks, cleanup_expired_callbacks
from bot.progress import progress_tracker

logger = logging.getLogger(__name__)

# Create admin queue router
admin_queue_router = Router()

# Global task manager
task_manager = get_task_manager()


@admin_queue_router.message(Command("admin_queue_status"))
async def cmd_admin_queue_status(message: Message) -> None:
    """Admin command: Get queue system status."""
    if not AdminManager.is_admin(message.from_user.id):
        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞")
        return
    
    try:
        # Get queue statistics
        queue_stats = task_manager.get_queue_stats()
        
        # Get system health
        health_status = task_manager.health_check()
        
        # Format status message
        status_message = "üìä <b>–°—Ç–∞—Ç—É—Å –æ—á–µ—Ä–µ–¥–µ–π –∑–∞–¥–∞—á</b>\n\n"
        
        # Redis status
        redis_status = health_status.get("redis_connection", "unknown")
        redis_emoji = "‚úÖ" if redis_status == "healthy" else "‚ùå"
        status_message += f"{redis_emoji} <b>Redis:</b> {redis_status}\n"
        
        if health_status.get("redis_error"):
            status_message += f"‚ùó –û—à–∏–±–∫–∞: {health_status['redis_error']}\n"
        
        status_message += f"üîÑ <b>–ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏:</b> {health_status.get('active_tasks', 0)}\n"
        status_message += f"‚è∞ <b>–ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ:</b> {health_status.get('scheduled_tasks', 0)}\n\n"
        
        # Queue details
        status_message += "üìã <b>–î–µ—Ç–∞–ª–∏ –æ—á–µ—Ä–µ–¥–µ–π:</b>\n"
        
        priority_names = {\n            "faceit_bot_critical": "üö® –ö—Ä–∏—Ç–∏—á–Ω—ã–µ",\n            "faceit_bot_high": "‚ö° –í—ã—Å–æ–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç",\n            "faceit_bot_default": "üì¶ –û–±—ã—á–Ω—ã–µ",\n            "faceit_bot_low": "üêå –ù–∏–∑–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç"\n        }\n        \n        total_queued = total_started = total_finished = total_failed = 0\n        \n        for queue_name, stats in queue_stats.items():\n            if isinstance(stats, dict) and "error" not in stats:\n                queued = stats.get("queued_jobs", 0)\n                started = stats.get("started_jobs", 0)\n                finished = stats.get("finished_jobs", 0)\n                failed = stats.get("failed_jobs", 0)\n                \n                total_queued += queued\n                total_started += started\n                total_finished += finished\n                total_failed += failed\n                \n                queue_display = priority_names.get(queue_name, queue_name)\n                status_message += f"‚Ä¢ {queue_display}:\\n"\n                status_message += f"  –û—á–µ—Ä–µ–¥—å: {queued} | –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è: {started} | –ì–æ—Ç–æ–≤–æ: {finished} | –û—à–∏–±–∫–∏: {failed}\\n"\n            else:\n                queue_display = priority_names.get(queue_name, queue_name)\n                error_msg = stats.get("error", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞") if isinstance(stats, dict) else str(stats)\n                status_message += f"‚Ä¢ {queue_display}: ‚ùå {error_msg}\\n"\n        \n        # Totals\n        status_message += "\\nüìä <b>–ò—Ç–æ–≥–æ:</b>\\n"\n        status_message += f"‚Ä¢ –í –æ—á–µ—Ä–µ–¥–∏: {total_queued}\\n"\n        status_message += f"‚Ä¢ –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è: {total_started}\\n"\n        status_message += f"‚Ä¢ –ó–∞–≤–µ—Ä—à–µ–Ω–æ: {total_finished}\\n"\n        status_message += f"‚Ä¢ –û—à–∏–±–∫–∏: {total_failed}\\n"\n        \n        if total_finished + total_failed > 0:\n            success_rate = round((total_finished / (total_finished + total_failed)) * 100, 1)\n            status_message += f"‚Ä¢ –£—Å–ø–µ—à–Ω–æ—Å—Ç—å: {success_rate}%\\n"\n        \n        # Create management keyboard\n        keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [\n                InlineKeyboardButton(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data="admin_queue_refresh"),\n                InlineKeyboardButton(text="üìä –ú–µ—Ç—Ä–∏–∫–∏", callback_data="admin_queue_metrics")\n            ],\n            [\n                InlineKeyboardButton(text="üßπ –û—á–∏—Å—Ç–∏—Ç—å", callback_data="admin_queue_cleanup"),\n                InlineKeyboardButton(text="üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏", callback_data="admin_queue_users")\n            ]\n        ])\n        \n        await message.answer(status_message, parse_mode=ParseMode.HTML, reply_markup=keyboard)\n        \n    except Exception as e:\n        logger.error(f"Error getting queue status: {e}")\n        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –æ—á–µ—Ä–µ–¥–µ–π")\n\n\n@admin_queue_router.message(Command("admin_queue_metrics"))\nasync def cmd_admin_queue_metrics(message: Message) -> None:\n    \"\"\"Admin command: Get detailed queue metrics.\"\"\"\n    if not AdminManager.is_admin(message.from_user.id):\n        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞")\n        return\n    \n    try:\n        # Get system metrics\n        metrics = task_manager.get_system_metrics()\n        \n        if "error" in metrics:\n            await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ—Ç—Ä–∏–∫: {metrics['error']}")\n            return\n        \n        # Format metrics message\n        metrics_message = "üìà <b>–î–µ—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ —Å–∏—Å—Ç–µ–º—ã</b>\\n\\n"\n        \n        # Redis metrics\n        redis_metrics = metrics.get("redis_metrics", {})\n        metrics_message += "üî¥ <b>Redis:</b>\\n"\n        metrics_message += f"‚Ä¢ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {redis_metrics.get('connected_clients', 0)}\\n"\n        metrics_message += f"‚Ä¢ –ü–∞–º—è—Ç—å: {redis_metrics.get('used_memory_human', '0B')}\\n"\n        metrics_message += f"‚Ä¢ –ö–æ–º–∞–Ω–¥—ã: {redis_metrics.get('total_commands_processed', 0):,}\\n"\n        \n        keyspace_hits = redis_metrics.get('keyspace_hits', 0)\n        keyspace_misses = redis_metrics.get('keyspace_misses', 0)\n        if keyspace_hits + keyspace_misses > 0:\n            hit_rate = round((keyspace_hits / (keyspace_hits + keyspace_misses)) * 100, 1)\n            metrics_message += f"‚Ä¢ Hit Rate: {hit_rate}%\\n"\n        \n        metrics_message += "\\n"\n        \n        # Job statistics\n        job_stats = metrics.get("job_statistics", {})\n        metrics_message += "üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–¥–∞—á:</b>\\n"\n        metrics_message += f"‚Ä¢ –í—Å–µ–≥–æ –∑–∞–¥–∞—á: {job_stats.get('total_jobs', 0):,}\\n"\n        metrics_message += f"‚Ä¢ –í –æ—á–µ—Ä–µ–¥–∏: {job_stats.get('total_queued', 0)}\\n"\n        metrics_message += f"‚Ä¢ –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è: {job_stats.get('total_started', 0)}\\n"\n        metrics_message += f"‚Ä¢ –ó–∞–≤–µ—Ä—à–µ–Ω–æ: {job_stats.get('total_finished', 0):,}\\n"\n        metrics_message += f"‚Ä¢ –û—à–∏–±–∫–∏: {job_stats.get('total_failed', 0)}\\n"\n        metrics_message += f"‚Ä¢ –£—Å–ø–µ—à–Ω–æ—Å—Ç—å: {job_stats.get('success_rate', 0)}%\\n\\n"\n        \n        # Task management\n        task_mgmt = metrics.get("task_management", {})\n        metrics_message += "üéØ <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∞–º–∏:</b>\\n"\n        metrics_message += f"‚Ä¢ –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç—Å—è: {task_mgmt.get('active_tasks_tracked', 0)}\\n"\n        metrics_message += f"‚Ä¢ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ: {task_mgmt.get('scheduled_tasks', 0)}\\n"\n        metrics_message += f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω–æ: {task_mgmt.get('enabled_scheduled_tasks', 0)}\\n\\n"\n        \n        # Tracking info\n        tracked_tasks = progress_tracker.get_tracked_tasks()\n        registered_callbacks = get_registered_callbacks()\n        active_users = len(user_active_tasks)\n        \n        metrics_message += "üë• <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∑–∞–¥–∞—á–∏:</b>\\n"\n        metrics_message += f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏: {active_users}\\n"\n        metrics_message += f"‚Ä¢ –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ –∑–∞–¥–∞—á–∏: {len(tracked_tasks)}\\n"\n        metrics_message += f"‚Ä¢ –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ callbacks: {len(registered_callbacks)}\\n"\n        \n        await message.answer(metrics_message, parse_mode=ParseMode.HTML)\n        \n    except Exception as e:\n        logger.error(f"Error getting queue metrics: {e}")\n        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –º–µ—Ç—Ä–∏–∫ –æ—á–µ—Ä–µ–¥–µ–π")\n\n\n@admin_queue_router.message(Command("admin_queue_cleanup"))\nasync def cmd_admin_queue_cleanup(message: Message) -> None:\n    \"\"\"Admin command: Clean up completed tasks.\"\"\"\n    if not AdminManager.is_admin(message.from_user.id):\n        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞")\n        return\n    \n    try:\n        # Parse hours parameter\n        hours = 24  # default\n        if message.text:\n            args = message.text.split()[1:]\n            if args and args[0].isdigit():\n                hours = int(args[0])\n        \n        await message.answer(\n            f"üßπ <b>–û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö –∑–∞–¥–∞—á...</b>\\n\\n"\n            f"‚è∞ –£–¥–∞–ª—è–µ–º –∑–∞–¥–∞—á–∏ —Å—Ç–∞—Ä—à–µ {hours} —á–∞—Å–æ–≤...",\n            parse_mode=ParseMode.HTML\n        )\n        \n        # Clean up finished tasks\n        cleaned_tasks = task_manager.cleanup_finished_tasks(older_than_hours=hours)\n        \n        # Clean up tracking data\n        await cleanup_completed_tasks()\n        await cleanup_expired_callbacks(max_age_hours=hours)\n        await progress_tracker.cleanup_stale_tasks(max_age_hours=hours)\n        \n        result_message = (\n            f"‚úÖ <b>–û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\\n\\n"\n            f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö –∑–∞–¥–∞—á: {cleaned_tasks}\\n"\n            f"‚è∞ –í–æ–∑—Ä–∞—Å—Ç: —Å—Ç–∞—Ä—à–µ {hours} —á–∞—Å–æ–≤\\n"\n            f"üßπ –¢–∞–∫–∂–µ –æ—á–∏—â–µ–Ω—ã:\\n"\n            f"‚Ä¢ –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞\\n"\n            f"‚Ä¢ Callbacks\\n"\n            f"‚Ä¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∑–∞–¥–∞—á–∏"\n        )\n        \n        await message.answer(result_message, parse_mode=ParseMode.HTML)\n        \n    except ValueError:\n        await message.answer(\n            "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã\\n\\n"\n            "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /admin_queue_cleanup [—á–∞—Å—ã]\\n"\n            "–ü—Ä–∏–º–µ—Ä: /admin_queue_cleanup 48",\n            parse_mode=ParseMode.HTML\n        )\n    except Exception as e:\n        logger.error(f"Error cleaning up queues: {e}")\n        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –æ—á–µ—Ä–µ–¥–µ–π")\n\n\n@admin_queue_router.message(Command("admin_queue_users"))\nasync def cmd_admin_queue_users(message: Message) -> None:\n    \"\"\"Admin command: Show active users and their tasks.\"\"\"\n    if not AdminManager.is_admin(message.from_user.id):\n        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞")\n        return\n    \n    try:\n        if not user_active_tasks:\n            await message.answer(\n                "üë• <b>–ê–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏</b>\\n\\n"\n                "üì≠ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –∑–∞–¥–∞—á",\n                parse_mode=ParseMode.HTML\n            )\n            return\n        \n        users_message = "üë• <b>–ê–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∏ –∑–∞–¥–∞—á–∏</b>\\n\\n"\n        \n        for user_id, tasks in user_active_tasks.items():\n            users_message += f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> <code>{user_id}</code>\\n"\n            users_message += f"üìù <b>–ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á:</b> {len(tasks)}\\n"\n            \n            # Show task details\n            for task_id in tasks:\n                try:\n                    status = task_manager.get_task_status(task_id)\n                    task_status = status.get("status", "unknown")\n                    \n                    # Status emoji\n                    status_emoji = {\n                        "queued": "‚è≥",\n                        "started": "üîÑ",\n                        "finished": "‚úÖ",\n                        "failed": "‚ùå",\n                        "cancelled": "üö´"\n                    }.get(task_status, "‚ùì")\n                    \n                    users_message += f"  {status_emoji} <code>{task_id[:8]}...</code> - {task_status}\\n"\n                    \n                except Exception:\n                    users_message += f"  ‚ùì <code>{task_id[:8]}...</code> - —Å—Ç–∞—Ç—É—Å –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω\\n"\n            \n            users_message += "\\n"\n        \n        # Split message if too long\n        if len(users_message) > 4000:\n            # Send in parts\n            parts = []\n            current_part = ""\n            lines = users_message.split('\\n')\n            \n            for line in lines:\n                if len(current_part + line + '\\n') > 3900:\n                    if current_part:\n                        parts.append(current_part.strip())\n                        current_part = line + '\\n'\n                    else:\n                        parts.append(line)\n                else:\n                    current_part += line + '\\n'\n            \n            if current_part:\n                parts.append(current_part.strip())\n            \n            for i, part in enumerate(parts):\n                if i == 0:\n                    await message.answer(part, parse_mode=ParseMode.HTML)\n                else:\n                    await message.answer(\n                        f"<b>–ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ...</b>\\n\\n{part}",\n                        parse_mode=ParseMode.HTML\n                    )\n        else:\n            await message.answer(users_message, parse_mode=ParseMode.HTML)\n        \n    except Exception as e:\n        logger.error(f"Error getting queue users: {e}")\n        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è—Ö")\n\n\n@admin_queue_router.message(Command("admin_task_retry"))\nasync def cmd_admin_task_retry(message: Message) -> None:\n    \"\"\"Admin command: Retry failed task.\"\"\"\n    if not AdminManager.is_admin(message.from_user.id):\n        await message.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞")\n        return\n    \n    if not message.text:\n        return\n    \n    args = message.text.split()[1:]\n    if not args:\n        await message.answer(\n            "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /admin_task_retry <task_id>\\n"\n            "–ü—Ä–∏–º–µ—Ä: /admin_task_retry abc123-def456",\n            parse_mode=ParseMode.HTML\n        )\n        return\n    \n    task_id = args[0]\n    \n    try:\n        # Retry the task\n        new_task_id = task_manager.retry_failed_task(task_id)\n        \n        if new_task_id:\n            await message.answer(\n                f"‚úÖ <b>–ó–∞–¥–∞—á–∞ –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω–∞!</b>\\n\\n"\n                f"üîÑ –°—Ç–∞—Ä–∞—è –∑–∞–¥–∞—á–∞: <code>{task_id}</code>\\n"\n                f"üÜï –ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞: <code>{new_task_id}</code>",\n                parse_mode=ParseMode.HTML\n            )\n        else:\n            await message.answer(\n                f"‚ùå <b>–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –∑–∞–¥–∞—á—É</b>\\n\\n"\n                f"üÜî ID: <code>{task_id}</code>\\n"\n                f"üí° –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\\n"\n                f"‚Ä¢ –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞\\n"\n                f"‚Ä¢ –ó–∞–¥–∞—á–∞ –Ω–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –æ—à–∏–±–∫–∏\\n"\n                f"‚Ä¢ –°–∏—Å—Ç–µ–º–Ω–∞—è –æ—à–∏–±–∫–∞",\n                parse_mode=ParseMode.HTML\n            )\n        \n    except Exception as e:\n        logger.error(f"Error retrying task {task_id}: {e}")\n        await message.answer(\n            f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–µ –∑–∞–¥–∞—á–∏\\n\\n"\n            f"üÜî ID: <code>{task_id}</code>\\n"\n            f"‚ùó –û—à–∏–±–∫–∞: {str(e)}",\n            parse_mode=ParseMode.HTML\n        )\n\n\n# Callback handlers for admin queue management\n\n@admin_queue_router.callback_query(F.data == "admin_queue_refresh")\nasync def handle_admin_queue_refresh(callback: CallbackQuery) -> None:\n    \"\"\"Handle queue status refresh.\"\"\"\n    if not AdminManager.is_admin(callback.from_user.id):\n        await callback.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞", show_alert=True)\n        return\n    \n    await callback.answer("üîÑ –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å...")\n    \n    # Simulate the queue status command\n    await cmd_admin_queue_status(callback.message)\n\n\n@admin_queue_router.callback_query(F.data == "admin_queue_metrics")\nasync def handle_admin_queue_metrics(callback: CallbackQuery) -> None:\n    \"\"\"Handle queue metrics request.\"\"\"\n    if not AdminManager.is_admin(callback.from_user.id):\n        await callback.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞", show_alert=True)\n        return\n    \n    await callback.answer("üìä –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏...")\n    \n    # Simulate the metrics command\n    await cmd_admin_queue_metrics(callback.message)\n\n\n@admin_queue_router.callback_query(F.data == "admin_queue_cleanup")\nasync def handle_admin_queue_cleanup(callback: CallbackQuery) -> None:\n    \"\"\"Handle queue cleanup request.\"\"\"\n    if not AdminManager.is_admin(callback.from_user.id):\n        await callback.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞", show_alert=True)\n        return\n    \n    await callback.answer("üßπ –ó–∞–ø—É—Å–∫–∞–µ–º –æ—á–∏—Å—Ç–∫—É...")\n    \n    # Simulate the cleanup command with default parameters\n    await cmd_admin_queue_cleanup(callback.message)\n\n\n@admin_queue_router.callback_query(F.data == "admin_queue_users")\nasync def handle_admin_queue_users(callback: CallbackQuery) -> None:\n    \"\"\"Handle active users request.\"\"\"\n    if not AdminManager.is_admin(callback.from_user.id):\n        await callback.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞", show_alert=True)\n        return\n    \n    await callback.answer("üë• –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π...")\n    \n    # Simulate the users command\n    await cmd_admin_queue_users(callback.message)